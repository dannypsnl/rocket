<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rocket</title><link>http://dannypsnl.github.io/rocket/</link><description>Recent content on Rocket</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 17 Feb 2019 14:09:30 +0800</lastBuildDate><atom:link href="http://dannypsnl.github.io/rocket/index.xml" rel="self" type="application/rss+xml"/><item><title>Server</title><link>http://dannypsnl.github.io/rocket/documents/server/</link><pubDate>Tue, 25 Sep 2018 21:16:07 +0800</pubDate><guid>http://dannypsnl.github.io/rocket/documents/server/</guid><description>To create a server, we have to start from Ignite.
rocket.Ignite(&amp;#34;:8080&amp;#34;) We use the same pattern as Go native http package.
So I think it won&amp;rsquo;t be to hard to notice :8080 means listen port 8080.
Then we will use Mount mounts some handlers.
rocket.Ignite(&amp;#34;:8080&amp;#34;). Mount(handler) The thing you should know is you can mount several handlers at one Mount call. For example:
rocket.Ignite(&amp;#34;:8080&amp;#34;). Mount(handler1, handler2) // and below And the important thing is we high recommended you writing like:</description></item><item><title>Request handler &amp; Context</title><link>http://dannypsnl.github.io/rocket/documents/handler_and_context/</link><pubDate>Tue, 25 Sep 2018 21:33:47 +0800</pubDate><guid>http://dannypsnl.github.io/rocket/documents/handler_and_context/</guid><description>Rocket&amp;rsquo;s handler contains two parts.
variant route handle function Basically, we have the creator for handler. It uses like:
package example import ( &amp;#34;github.com/dannypsnl/rocket&amp;#34; ) func handler() string { return &amp;#34;&amp;#34; } func main() { // In `Mount` rocket.Get(&amp;#34;/hello&amp;#34;, handler) } Now we have a handler function handler, and we can use a route &amp;quot;/hello and handler to create a new Rocket&amp;rsquo;s handler. When request path matches this route, the response is response of handler function.</description></item><item><title>Response</title><link>http://dannypsnl.github.io/rocket/documents/response/</link><pubDate>Fri, 28 Sep 2018 23:55:05 +0800</pubDate><guid>http://dannypsnl.github.io/rocket/documents/response/</guid><description>Note: In following context, we only show handle function
Warning: Don&amp;rsquo;t use *response.Response cross goroutine, it&amp;rsquo;s not designed to be thread-safe(and it don&amp;rsquo;t have to be)
Basically rocket contains some type to help you return value more easier
For example, response.Html
func() response.Html { return `&amp;lt;h1&amp;gt;Title&amp;lt;/h1&amp;gt;` } Then your response when with header Content-Type is text/html
Currently we have:
response.Html, return text/html response.Json, return application/json func() response.</description></item><item><title>Fairing</title><link>http://dannypsnl.github.io/rocket/documents/fairing/</link><pubDate>Sat, 02 Feb 2019 22:39:18 +0800</pubDate><guid>http://dannypsnl.github.io/rocket/documents/fairing/</guid><description>What&amp;rsquo;s fairing? It&amp;rsquo;s an abstraction to avoid over-using the middleware.
But we still need some hooks to record some data or modifying the input/output for certain purpose, to keep this ability, we made fairing, this is how it looks like:
package example type Logger struct { rocket.Fairing } func (l *Logger) OnRequest(r *http.Request) *http.Request { log.Printf(&amp;#34;request: %#v\n&amp;#34;, r) return r } func (l *Logger) OnResponse(r *response.Response) *response.Response { log.Printf(&amp;#34;response: %#v\n&amp;#34;, r) return r } // in main function or entrypoint rocket.</description></item><item><title>Guard</title><link>http://dannypsnl.github.io/rocket/documents/guard/</link><pubDate>Sun, 17 Feb 2019 14:09:30 +0800</pubDate><guid>http://dannypsnl.github.io/rocket/documents/guard/</guid><description>A guard is a type that implemented the interface rocket.Guard, it can reject a request by returning an error.
Here is an easy example:
type User struct { Authorization *string `header:&amp;#34;Authorization&amp;#34;` } func (u *User) VerifyRequest() error { // Assuming we have a JWT verify helper function if verifyAuthByJWT(u.Auth) { return nil } return rocket.AuthError(&amp;#34;not allowed&amp;#34;) } var handler = rocket.Get(&amp;#34;/user_data&amp;#34;, func() string { // would return data if `VerifyRequest` do not return any errors }).</description></item><item><title>Minimum Example</title><link>http://dannypsnl.github.io/rocket/quick_start/minimum_example/</link><pubDate>Sun, 23 Sep 2018 23:51:06 +0800</pubDate><guid>http://dannypsnl.github.io/rocket/quick_start/minimum_example/</guid><description>Before you write down any code. You need to import the package.
import ( &amp;#34;github.com/dannypsnl/rocket&amp;#34; ) With Rocket, you will create a lots of handler function, here is a basic handler function with user-defined context.
type User struct { Name string `route:&amp;#34;name&amp;#34;` Age uint64 `route:&amp;#34;age&amp;#34;` } func hello(u *User) string { return &amp;#34;Hello &amp;#34; + u.Name + &amp;#34;, your age is &amp;#34; + strconv.FormatUint(u.Age, 10) } How to let it work?</description></item></channel></rss>