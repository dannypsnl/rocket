[{"uri":"http://dannypsnl.github.io/rocket/quick_start/","title":"QuickStart","tags":[],"description":"","content":"Rocket Quick Start Discover what the Rocket can do for you.\n"},{"uri":"http://dannypsnl.github.io/rocket/documents/","title":"Documents","tags":[],"description":"","content":"Rocket Documents Explain how to use Rocket\n"},{"uri":"http://dannypsnl.github.io/rocket/documents/server/","title":"Server","tags":[],"description":"","content":"To create a server, we have to start from Ignite.\nrocket.Ignite(\u0026#34;:8080\u0026#34;) We use the same pattern as Go native http package.\nSo I think it won\u0026rsquo;t be to hard to notice :8080 means listen port 8080.\nThen we will use Mount mounts some handlers.\nrocket.Ignite(\u0026#34;:8080\u0026#34;). Mount(handler) The thing you should know is you can mount several handlers at one Mount call. For example:\nrocket.Ignite(\u0026#34;:8080\u0026#34;). Mount(handler1, handler2) // and below And the important thing is we high recommended you writing like:\nrocket.Ignite(\u0026#34;:8080\u0026#34;). Mount( rocket.Get(\u0026#34;/\u0026#34;, handlerFunction), ) To make route visible when you defining them.\nNext is handling Not Found: 404, we use Default to handle this.\nrocket.Ignite(\u0026#34;:8080\u0026#34;). // some mounts  Default(func() response.Html { return `\u0026lt;h1\u0026gt;Page Not Found\u0026lt;/h1\u0026gt;` }) Then when rocket can\u0026rsquo;t find any route in router, it will use this function\u0026rsquo;s response. This is optional, so you can omit it, we have default for default, lol.\np.s. response.Html is response magic in rocket, it will set header Content-Type as text/html. Then you will see the browser render respnose as HTML\nFinal, we start our server.\nrocket.Ignite(\u0026#34;:8080\u0026#34;). // some mounts \u0026amp; default  Launch() Call Launch will start our server, now you can use any HTTP client to see localhost:8080\nAdditional API EnableHTTPs, we can create a https server by calling EnableHTTPs.\nrocket.Ignite(\u0026#34;:8080\u0026#34;). EnableHTTPs(\u0026#34;cert.pem\u0026#34;, \u0026#34;key.pem\u0026#34;). Launch() Parameters are same as func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error.\n"},{"uri":"http://dannypsnl.github.io/rocket/documents/handler_and_context/","title":"Request handler &amp; Context","tags":[],"description":"","content":"Rocket\u0026rsquo;s handler contains two parts.\n variant route handle function  Basically, we have the creator for handler. It uses like:\npackage example import ( \u0026#34;github.com/dannypsnl/rocket\u0026#34; ) func handler() string { return \u0026#34;\u0026#34; } func main() { // In `Mount`  rocket.Get(\u0026#34;/hello\u0026#34;, handler) } Now we have a handler function handler, and we can use a route \u0026quot;/hello and handler to create a new Rocket\u0026rsquo;s handler. When request path matches this route, the response is response of handler function.\nWe have following creator mapping to HTTP method currently.\n Get HTTP Method GET Post HTTP Method POST Put HTTP Method PUT Patch HTTP Method PATCH Delete HTTP Method DELETE  Now you already know how to create handler has different method. Let\u0026rsquo;s look the most interesting feature of rocket User-defined Context\nSo the question is, how to have one in rocket?\npackage example type User struct { Name string `route:\u0026#34;name\u0026#34;` Age uint64 `route:\u0026#34;age\u0026#34;` } Don\u0026rsquo;t be surprised, that\u0026rsquo;s all, and then we use the type you create as parameter of your handle function\npackage example import ( \u0026#34;github.com/dannypsnl/rocket\u0026#34; ) func main() { // In `Mount`  rocket.Get(\u0026#34;/:name/:age\u0026#34;, func (u *User) string { return \u0026#34;Hello \u0026#34; + u.Name + \u0026#34;, your age is \u0026#34; + strconv.FormatUint(u.Age, 10) }) } Ok, we know how to use the field of context, but where is it came from?\nLet\u0026rsquo;s return to \u0026quot;/:name/:age\u0026quot;, this is how we fill your context, in variant route, what you defined as :key things, will be the value of tag route:\u0026quot;key\u0026quot;\nAt here, we got route:\u0026quot;name\u0026quot; \u0026amp; route:\u0026quot;age\u0026quot;, so request path Danny/21 will let your context got string Danny \u0026amp; uint64 21\np.s. type of Age this field is uint64, so we will try to parsing the value of request path. If it\u0026rsquo;s not an uint64, then we return HTTP Status Code: 400.\nBut just route? Nope, we also have:\n  query:\u0026quot;key\u0026quot; for request path /path/to/route?key=value\n  form:\u0026quot;key\u0026quot; for FORM request\n  multiform:\u0026quot;key\u0026quot; for multiple forms request\n  multiform:\u0026quot;key\u0026quot; file:\u0026quot;yes\u0026quot; for multiple forms request, and it\u0026rsquo;s a file. In this case, the type of field must be io.ReadCloser.\n  json:\u0026quot;key\u0026quot; for request body is JSON(here has some problem, we can also handle GET method just need JSON body, this is a bug, it should only work with POST, PUT, PATCH with application/json)\n  header:\u0026quot;key\u0026quot;, to getting header like Content-Type, Authorization\n  cookie:\u0026quot;key\u0026quot;, a very important fact of cookie tag is it only accept you use *http.Cookie as field type, e.g.\npackage example import \u0026#34;net/http\u0026#34; type UserToken struct { token *http.Cookie `cookie:\u0026#34;token\u0026#34;` } and it would get the most matched cookie, so avoid using duplicate cookie name in your application would be better, another important thing is if no cookie matched, this tag won\u0026rsquo;t follow the optional contract, so don\u0026rsquo;t use cookie tag in a general purpose context would help you avoid Bad Request\n  Optional field We still have one thing haven\u0026rsquo;t been mentioned, optional field, just like its name, it allowed you omit the field and won\u0026rsquo;t cause HTTP Status Code: 400.\nExample context definition:\ntype Transaction struct { Amount uint64 `form:\u0026#34;amount\u0026#34;` Canceled *bool `form:\u0026#34;canceled\u0026#34;` } At here, the field Canceled would be nil if you didn\u0026rsquo;t give it a value.\nMultiple Contexts Multiple contexts allows you put more than one contexs in your handler function, this make you can reuse more contexts, for example, here is a proxy of kubernetes List API:\nimport ( \u0026#34;net/http\u0026#34; corev1 \u0026#34;k8s.io/api/core/v1\u0026#34; metav1 \u0026#34;k8s.io/apimachinery/pkg/apis/meta/v1\u0026#34; scheme \u0026#34;k8s.io/client-go/kubernetes/scheme\u0026#34; \u0026#34;github.com/dannypsnl/rocket\u0026#34; \u0026#34;github.com/dannypsnl/rocket/response\u0026#34; ) type ( CheckWatch struct { IsWatch *bool `query:\u0026#34;watch\u0026#34;` } Resource struct { Namespace string `route:\u0026#34;namespace\u0026#34;` Kind string `route:\u0026#34;kind\u0026#34;` } ) // ignore all errors func kubernetesProxy(c *CheckWatch, r *Resource) response.Json { opts := \u0026amp;metav1.ListOptions{} if c.IsWatch != nil \u0026amp;\u0026amp; *c.IsWatch { return response.Stream(func(w http.ResponseWriter) { opts.Watch = true watchInterface, err := kubeClient.CoreV1().RESTClient().Get(). Namespace(r.Namespace). Resource(r.Kind). VersionedParams(opts, scheme.ParameterCodec). Watch() for { select { case event := \u0026lt;- watchInterface.ResultChan(): data, err := json.Marshal(event.Object) w.Write(data) } } }). Headers(response.Headers{ \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, }) } // We should create result by Kind actually, but just let me use hard code here as an example  result := \u0026amp;corev1.EndpointsList{} // ignore how to initialize kubeClient  err := kubeClient.CoreV1().RESTClient().Get(). Namespace(r.Namespace). Resource(r.Kind). VersionedParams(opts, scheme.ParameterCodec). Do(). Into(result) data, err := json.Marshal(result) return response.Json(data) } rocket. // ignore  Mount( rocket.Get(\u0026#34;/api/v1/namespaces/:namespace/:kind\u0026#34;, kubernetesProxy), ). Launch() "},{"uri":"http://dannypsnl.github.io/rocket/documents/response/","title":"Response","tags":[],"description":"","content":" Note: In following context, we only show handle function\n  Warning: Don\u0026rsquo;t use *response.Response cross goroutine, it\u0026rsquo;s not designed to be thread-safe(and it don\u0026rsquo;t have to be)\n Basically rocket contains some type to help you return value more easier\nFor example, response.Html\nfunc() response.Html { return `\u0026lt;h1\u0026gt;Title\u0026lt;/h1\u0026gt;` } Then your response when with header Content-Type is text/html\nCurrently we have:\n response.Html, return text/html response.Json, return application/json func() response.Json { return ` { \u0026#34;just\u0026#34;: \u0026#34;a json\u0026#34; } ` }  string, return text/plain  Response is defined under github.com/dannypsnl/rocket/response this package\nimport \u0026#34;github.com/dannypsnl/rocket/response\u0026#34; func() *response.Response { html := response.Html(` \u0026lt;h1\u0026gt;Title\u0026lt;/h1\u0026gt; `) return response.New(html) } As you can see, you can keep your awesome response type feature with Response\nFactory functions:\n  New, accept a response type of rocket\nresponse.New(\u0026#34;what your user get\u0026#34;)   Stream, create a streamable responder by allowing you keep writing data into http.ResponseWriter\nresponse.Stream(func(w http.ResponseWriter) (keep bool) { _, err := w.Write([]byte(`hello\\n`)) if err != nil { return false } return true }) This is because Go http package help you could use HTTP/1.1 connection as streaming by ignoring EOF, and somehow we found this is really useful so we keep this ability in rocket\n  Here is all methods of Response:\n  Headers, accept a header map\nresponse.New(\u0026#34;\u0026#34;).Headers(response.Headers{ \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, })   Cookies, accept a cookie list\nresponse.New(\u0026#34;\u0026#34;).Cookies( cookie.New(\u0026#34;a\u0026#34;, \u0026#34;cookie\u0026#34;). Expires(time.Now().Add(time.Hour * 24)), cookie.New(\u0026#34;more\u0026#34;, \u0026#34;cookie\u0026#34;). Expires(time.Now().Add(time.Hour * 24)), )   Status, accept a new status code, it would panic when you give a invalid status code(by RFC, it should be a 3 digit integer) or you try to rewrite it\nresponse.New(\u0026#34;Bas request\u0026#34;). Status(http.StatusBadRequest)   ContentType, let you modify content-type of response easier(compare to setting header directly)\nresponse.Stream(func(w http.ResponseWriter) bool { // ignore }). ContentType(\u0026#34;application/json\u0026#34;)   "},{"uri":"http://dannypsnl.github.io/rocket/documents/fairing/","title":"Fairing","tags":[],"description":"","content":"What\u0026rsquo;s fairing? It\u0026rsquo;s an abstraction to avoid over-using the middleware.\nBut we still need some hooks to record some data or modifying the input/output for certain purpose, to keep this ability, we made fairing, this is how it looks like:\npackage example type Logger struct { rocket.Fairing } func (l *Logger) OnRequest(r *http.Request) *http.Request { log.Printf(\u0026#34;request: %#v\\n\u0026#34;, r) return r } func (l *Logger) OnResponse(r *response.Response) *response.Response { log.Printf(\u0026#34;response: %#v\\n\u0026#34;, r) return r } // in main function or entrypoint rocket.Ignite(\u0026#34;:8080\u0026#34;). Attach(\u0026amp;Logger{}). // Mount...  Launch() We can see some points, first, we can implement two kinds of fairing callbacks\n  func OnRequest(r *http.Request) *http.Request\nthis would be called before handlers get request\n  func OnResponse(r *response.Response) *response.Response\nthis would be called after handlers done handling\n  func OnLaunch(r *rocket.Rocket)\nthis would be called at launch time and get meta data of rocket\nFor example:\npackage example func (c *Configurator) OnLaunch(r *rocket.Rocket) { r.MultiFormBodySizeLimit = 20 // 20 MB }   then we can use the fairing implementor by using Attach method to emit it. We can call Attach several times, but carefully with it since it could modify request and response!\nWhy embedded rocket.Fairing? It would provide default behavior for OnRequest and OnResponse if you didn\u0026rsquo;t provide one, so it\u0026rsquo;s a good practice to embedded since we could add more fairing methods into it.\n"},{"uri":"http://dannypsnl.github.io/rocket/documents/guard/","title":"Guard","tags":[],"description":"","content":"A guard is a type that implemented the interface rocket.Guard, it can reject a request by returning an error.\nHere is an easy example:\ntype User struct { Authorization *string `header:\u0026#34;Authorization\u0026#34;` } func (u *User) VerifyRequest() error { // Assuming we have a JWT verify helper function  if verifyAuthByJWT(u.Auth) { return nil } return rocket.AuthError(\u0026#34;not allowed\u0026#34;) } var handler = rocket.Get(\u0026#34;/user_data\u0026#34;, func() string { // would return data if `VerifyRequest` do not return any errors }).Guard(\u0026amp;User{}) Possible Errors   normal error: usually should be returned by helper function in your VerifyRequest method, since it would make Status be 500 Internal Server Error\n  rocket.AuthError: should be returned when you believe it\u0026rsquo;s an Authorization error, it would bring 403 Forbidden\nrocket.AuthError(\u0026#34;auth error, error: %s\u0026#34;, err)   rocket.ValidateError: should be returned when you think the request was something wrong, it would return 400 Bad Request\nrocket.ValidateError(\u0026#34;auth error, error: %s\u0026#34;, err)   "},{"uri":"http://dannypsnl.github.io/rocket/","title":"","tags":[],"description":"","content":"Rocket Document "},{"uri":"http://dannypsnl.github.io/rocket/quick_start/minimum_example/","title":"Minimum Example","tags":[],"description":"","content":"Before you write down any code. You need to import the package.\nimport ( \u0026#34;github.com/dannypsnl/rocket\u0026#34; ) With Rocket, you will create a lots of handler function, here is a basic handler function with user-defined context.\ntype User struct { Name string `route:\u0026#34;name\u0026#34;` Age uint64 `route:\u0026#34;age\u0026#34;` } func hello(u *User) string { return \u0026#34;Hello \u0026#34; + u.Name + \u0026#34;, your age is \u0026#34; + strconv.FormatUint(u.Age, 10) } How to let it work?\n// main.go func main() { rocket.Ignite(\u0026#34;:8080\u0026#34;). Mount( // put `hello` under a path `/user/:name/:age`, where `:name` and `:age` are variant parameters  rocket.Get(\u0026#34;/user/:name/:age\u0026#34;, hello), ). Launch() } Now execute go run main.go, open your browser to localhost:8080/user/Danny/21.\nThen you will see Hello Danny, your age is 21.\nOr use curl:\n$ curl localhost:8080/user/Danny/21 Hello Danny, your age is 21 "},{"uri":"http://dannypsnl.github.io/rocket/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"http://dannypsnl.github.io/rocket/tags/","title":"Tags","tags":[],"description":"","content":""}]